# 객체 지향 프로그래밍

> 객체 지향이란 무엇일까? 

 저자는 객체 지향이란 무엇일까에 답변에 대한 예시를 다음과 같이 나열했다.
 
 1. 데이터와 함수의 조합
 2. 실제 세계를 모델링하는 새로운 방법
 
하지만 이 두 답변은 의도가 불분명하며, 정의가 너무 모호하다고 말한다.

***

> 그렇다면 객체지향의 본질을 설명할 때, 어떤 개념들을 말해야할까?

저자는 객체 지향을 설명하기 위해서는 **캡슐화(encapsulation)** , **상속(inheritance)** , **다형성(polymorphism)** 

위 세가지 개념이 포함되거나, 세 가지 요소를 반드시 지원해야한다고 말한다.

***
### 캡슐화
객체 지향을 정의하는 요소 중 하나로 캡슐화를 언급하는 이유는 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 '객체 지향' 언어가 제공하기 때문이다.

캡슐화란 '서로 연관있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로부터 보호하는 것'을 말한다.

- 데이터 보호 : 외부로부터 클래스에 정의된 속성과 기능들을 보호
- 데이터 은닉 : 내부의 동작을 감추고 외부에는 필요한 부분만 노출

즉, 외부로부터 클래스에 정의된 속성과 기능들을 보호하고, 필요한 부분만 외부로 노출될 수 있도록 하여, 각 객체 고유의 독립성과 책임 영역을 안전하게 지키고자 하는 목적이 있다.

Java에서 캡슐화를 구현하기 위한 방법은 접근제어자, getter/setter 이다.

먼저 접근제어자란 public, default, protected, private 총 4가지가 있다.

- public: 어떠한 클래스가 접근하든 모두 혀용
- protected: 상속받은 클래스 혹은 같은 패키지 내에서만 접근 가능
- default: 기본 제한자로써, 같은 클래스 내부와 같은 패키지 내에서만 접근 가능
- private: 같은 클래스 내에서만 접근이 가능하고, 외부에선 접근이 불가능

다음으로는 getter/setter를 아래의 예시로 설명할 수 있다. 이는 객체 무결성과도 연결되는데, 객체의 데이터를 외부에서 직접적으로 접근하는 것을 막기 때문이다.

<pre>
<code>
public class car{
    private String model;
    private String color;

    public String getModel() {
        return model;
    }

    public String getColor() {
        return color;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public void setColor(String color) {
        this.color = color;
    }
}
</code>
</pre>

***
### 상속

저자가 설명하는 상속이란, 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 것이라고 설명한다.  
좀더 덧붙여 설명하면 기존의 클래스에 기능을 추가하거나 재정의하여 새로운 클래스를 정의하는 것을 의미한다.

기존에 정의되어 있던 클래스는 'super class' 이고, 새롭게 작성되는 클래스를 'sub class' 라고 한다.

상속의 장점은 다음과 같다.
1. 기존에 작성된 클래스를 재활용
2. sub class 설계시, 중복되는 멤버를 미리 부모 클래스에 작성해 높으면, 자식 클래스에서는 해당 멤버를 작성하지 않음
3. 클래스 간의 계층적 관계를 구성함으로써, 다형성의 문법적 토대를 마련

<pre>
<code>
class Parent {
    public String name;
    
    public Parent(String name) {
        this.name = name;
    }
}

class child extends Parent {
    public int age;

    public Child(String name, int age) {
        super(name);
        this.age = age;
    }
}
</code>
</pre>

***
### 다형성
다형성이란 하나의 객체가 여러 가지 타입을 가질 수 있는 것을 말한다. 다형성을 설명하기 위해서는 상속관계, Override, 업캐스팅/다운캐스팅 등 많은 개념이 동반된다.
하지만 책의 내용을 기반으로 정리하기 때문에, 다음에 다룰 예정이다.

> 다형성이 가진 힘은 무엇일까?

다형성을 알아보기 위해, 복사 프로그램 예제를 알아보겠다. 만약 기존 복사 프로그램이 아닌, 새로운 입출력 장치가 생긴다면 어떻게 될까?

복사 프로그램의 코드에는 아무 변경이 필요없다. 심지어 복사 프로그램을 다시 컴파일할 필요조차 없다. 왜냐하면 복사 프로그램의 소스 코드는 입출력 드라이버의 소스코드에 의존하지 않기 때문이다.
즉 입출력 드라이버가 복사 프로그램의 플러그인이 된 것이다.

유닉스 운영체제에서 입출력 장치들을 플러그인 형태로 만든 이유는, 1950년대 후반 프로그램이 독립적이어야 하는 사실을 깨달았기 때문이다.
당시 장치에 의존적인 수많은 프로그램을 만들고 나서야, 프로그램이 다른 장치에서도 동일하게 작동하도록 만드는 것이 프로그래머들이 진정 바라던 일이라는 것을 인지했다.

플러그인 아키텍처는 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다. 
그럼에도 불구하고 그 당시 대다수의 프로그래머는 이러한 개념을 확장하여 적용하지 않았는데, 함수를 가리키는 포인터를 사용하면 위험을 수반하기 때문이었다.

하지만 객체 지향의 등장으로 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 되었다.

> 의존성의 역전(Dependency Inversion)

다형성을 안전하고 편리하게 적용할 수 있는 메커니즘 이전에의 호출 트리는 main -> 고수준 함수 -> 중간 수준 함수 -> 저수준 함수 순서로 호출했다.
이러한 호출 트리에서 소스 코드 의존성의 방향은 반드시 제어흐름을 따르게 된다.

![스크린샷 2024-08-14 오후 8 48 57](https://github.com/user-attachments/assets/37f77489-141b-49be-9274-6942019df1ce)


하지만 다형성을 적용하면 애기가 달라진다.

![스크린샷 2024-08-14 오후 8 24 33](https://github.com/user-attachments/assets/3c35303b-5878-4599-b4d8-e595c1aa22df)


HL1 모듈은 ML1모듈의 F() 함수를 호출한다. 소스코드에서는 HL1 모듈은 인터페이스를 통해 F() 함수를 호출한다. 이 인터페이스는 런타임에 존재하지 않는다.<br>
따라서 HL1은 단순히 ML1 모듈의 함수 F()를 호출하는 것이다. 하지만 ML1과 I 인터페이스 사이의 소스 코드 의존성(상속관계)은 제어 흐름과는 반대이다.

즉 위와 같은 상황을 의존성의 역전이라 부른다.

다시말해, 소스 코드 의존성은 소스 코드 사이에서 '인터페이스'를 추가함으로써 방향을 역전시킬 수 있다. 이러한 접근법을 사용한다면, 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않는다.
이것이 바로 객체 지향이 제공하는 힘이고, 지향하는 바이다.

![스크린샷 2024-08-14 오후 8 49 06](https://github.com/user-attachments/assets/c80321de-b986-42ed-ab60-a502d03f49a5)


위 사진처럼 Business Rule이 DB, UI에 의존하는 대신에, 시스템의 코드 의존성을 반대로 배치하여 DB, UI가 Business Rule에 의존하게 만들 수 있다.
즉 UI,DB가 Business Rule의 플러그인이 된다는 뜻이고, Business Rule의 소스코드에서는 UI, DB를 호출하지 않는다는 것이다.

***
### 결론
아키텍트 관점에서 객체 지향이란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
객체 지향을 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대한 독립성을 보장할 수 있다.
***

### 개인적인 소감
대학교 시절에 수강한 절차적 사고와 프로그래밍, 객체지향적 사고와 프로그래밍 수업 내용이 떠오르면서 교수님이 강조하셨던 말씀들이 다시 한번 생각났다. 
당시에는 잘 이해되지 않았던 부분이 책을 통해 조금이나마 더 이해되고 와닿는 느낌이 들었다.

지금까지 사용한 언어 'JAVA'의 본질에 대해 생각할 수 있는 좋은 시간이었다.
